# tree

## 1. 问题

## 2. 基础知识

### 2.1 引入

1. **二叉树基础概念**
   - 二叉树是一种数据结构，其中每个节点最多有两个子节点，通常分为左子节点和右子节点。
   - 根据节点之间的关系，二叉树有多种类型，如：二叉查找树（BST，Binary Search Tree），其中每个节点的值大于其左子树中的任何节点值且小于其右子树中的任何节点值；完全二叉树，满二叉树，平衡二叉树（例如AVL树、红黑树）等。
2. **二叉树节点定义**
   - 在C++中，一般会用类来表示二叉树节点，包含一个或多个数据成员以及指向左右子节点的指针。

```c++
struct TreeNode {
    int value; // 假设存储整数值
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : value(x), left(nullptr), right(nullptr) {}
};
```

3. **操作与遍历算法**

- **深度优先搜索（DFS）**：
  - **前序遍历**：先访问根节点，再遍历左子树，最后遍历右子树。
  - **中序遍历**：先遍历左子树，然后访问根节点，最后遍历右子树。
  - **后序遍历**：先遍历左子树，接着遍历右子树，最后访问根节点。
  - 这些遍历通常通过递归实现。
- **广度优先搜索（BFS）**：
  - 使用队列进行层次遍历，即从根节点开始，按层级顺序逐层访问所有节点。

4. **插入与删除节点**

- 插入新节点时需要保持二叉树性质（对于BST，确保新节点放在正确的位置以维持排序特性）。
- 删除节点时也需要考虑多种情况，如删除叶子节点、只有一个子节点的节点或有两个子节点的节点，并在删除后可能需要调整树结构以保持性质。

5. **实用函数与应用**

- 搜索特定值的节点。
- 计算树的高度。
- 判断是否为完全二叉树或满二叉树。
- 实现平衡操作（仅针对自平衡二叉树，如AVL树、红黑树）。

6. **内存管理**

- 动态创建和销毁二叉树节点，需妥善处理内存分配与释放问题，防止内存泄漏。

### 2.2 树的分类

在C++数据结构中，树（Tree）是一种非线性结构，用于表示具有层次关系的数据。树结构在计算机科学中被广泛应用，包括文件系统、XML和JSON解析、搜索引擎索引、数据库索引等。以下是一些常见的树的分类及其解释：

1. **二叉树（Binary Tree）：**
   - 每个节点最多有两个子节点，通常称为左子节点和右子节点。
   - 二叉树可以是空的，或者由一个根节点和两棵互不相交的、分别称为左子树和右子树的二叉树组成。
2. **完全二叉树（Complete Binary Tree）：**
   - 除最后一层外，每一层都被完全填充，并且所有节点都保持向左对齐。
   - 最后一层从左到右尽可能多地填充节点。
3. **满二叉树（Full Binary Tree）：**
   - 每一层（包括最后一层）都被完全填充。
   - 所有节点都有两个子节点或者没有子节点（叶子节点）。
4. **平衡二叉树（Balanced Binary Tree）：**
   - 任意节点的两个子树的高度差不超过1。
   - 常见的平衡二叉树有AVL树和红黑树。
5. **二叉搜索树（Binary Search Tree, BST）：**
   - 对于每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值。
   - 允许快速查找、插入和删除操作。
6. **B树（B-Tree）：**
   - 一种自平衡的搜索树，能够保持数据有序。
   - 每个节点有M-1个关键字和M个子树，其中M是预定义的阶数。
   - 常用于数据库和文件系统的索引结构。
7. **B+树（B+-Tree）：**
   - B树的一种变体，其中所有关键字都存储在叶子节点中。
   - 叶子节点之间以链表形式相连，便于范围查询。
   - 数据库索引和文件系统中经常使用B+树。
8. **哈夫曼树（Huffman Tree）：**
   - 一种带权路径长度最短的二叉树，也称为最优二叉树。
   - 用于哈夫曼编码，这是一种无损数据压缩算法。
9. **堆（Heap）：**
   - 一种特殊的完全二叉树或近似完全二叉树，其中父节点的值与其子节点的值之间存在一定的关系（最大堆或最小堆）。
   - 常用于实现优先队列。
10. **并查集（Disjoint Set Union, DSU）：**
    - 用于处理一些不交集（Disjoint Sets）的合并及查询问题。
    - 通常用有根树来表示，并通过路径压缩和按秩合并来优化性能。
    - 注意：并查集并不直接对应于一种特定的“树”结构，但常常用树来实现。

这些不同类型的树结构各有其特点和适用场景，在实际应用中需要根据具体需求选择合适的树结构来实现相应的功能。

## 3. 二叉树

[二叉树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/二叉树.md)

## 4. 二叉搜索树(BST)

[二叉搜索树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/二叉搜索树.md)

## 5. 二叉平衡树

[二叉平衡树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/二叉平衡树.md)

[红黑树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/红黑树.md)

## 6. B树

[B树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/B树.md)

## 7. B+树

[B+树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/B%2B树.md)

## 8. 哈夫曼树

[哈夫曼树.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/哈夫曼树.md)

## 9. 堆

[堆.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/堆.md)

## 10.并查集

[并查集.md](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/并查集.md)
