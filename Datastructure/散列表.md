# 散列表

## 1. 问题

## 2. 外部资料

## 3. 基本知识

### 3.1 什么是散列表

散列表（HashTable）是一种基于关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

散列表的存储思想是由关键字值决定数据的存储地址。通常，我们只需要O(1)的时间级就可以完成对数据的查找。散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。我们把对应关系f称为散列函数，又称为哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。关键字对应的记录存储位置我们称为散列地址。

散列技术既是一种存储方法，也是一种查找方法。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术则不存在。散列技术主要是面向查找的存储结构，它具备了既符合数据的逻辑结构又符合数据的存储结构的特点，所以可以保证最快速度的查找。

但是散列技术也存在一个不可避免的问题，那就是冲突。所谓冲突就是两个关键字经过散列函数的计算得到了相同的散列地址。冲突只能尽可能地减少，而不能完全避免。常用的解决冲突的方法有以下两种：开放寻址法（开放定址法）和链地址法（拉链法）。

### 3.2 什么是哈希函数

哈希函数（Hash Function）是一种将任意大小的输入数据映射到固定大小的哈希值（Hash Value）的函数。在密码学中，哈希函数主要用于加密、检索、索引和验证数据完整性。它将输入（通常是一段文本）通过散列算法，变换成固定长度的输出，该输出值称为哈希值或消息摘要。这个过程是单向的，即从哈希值无法推算出原始输入数据。哈希函数通常具有以下特性：

1. 可以应用于任意大小的数据块。
2. 产生定长的输出。
3. 对任意给定的输入，计算哈希值相对容易，用硬件和软件均可以实现。

哈希函数在密码学中有三个重要的安全性假设：

1. 单向性：对任意给定的哈希值h，找到满足H(x)=h的x在计算上是不可行的。
2. 抗弱碰撞性：对任意给定的输入x，找到满足y≠x，且H(x)=H(y)的y在计算上是不可行的。
3. 抗强碰撞性：找到任何满足H(x)=H(y)的偶对（x,y），其中x≠y，在计算上是不可行的。

满足这三个安全性假设的哈希函数被称为安全哈希函数或碰撞稳固的哈希函数。哈希函数在密码学、数据结构、网络安全等领域具有广泛的应用。

### 3.3 如何解决哈希冲突

哈希冲突是指两个或多个不同的输入数据经过哈希函数计算后得到相同的哈希值。由于哈希函数的输出空间通常是有限的，而输入数据可能是无限的，因此哈希冲突是不可避免的。不过，可以通过一些方法来减少或解决哈希冲突。

以下是解决哈希冲突的两种常见方法：

1. 链地址法（Separate Chaining）：
   - 在这种方法中，哈希表的每个位置都保存一个链表或其他动态集合，用于存储所有映射到该位置的元素。
   - 当发生哈希冲突时，新的元素会被添加到相应位置链表的末尾（或其他适当的动态集合中）。
   - 查找时需要遍历对应位置的链表来找到正确的元素。
   - 链地址法在处理冲突时具有较好的性能，尤其是当哈希表的大小可以动态调整时。
2. 开放寻址法（Open Addressing）：
   - 开放寻址法通过探测哈希表中的其他位置来解决冲突。
   - 当发生哈希冲突时，算法会按照某种探测序列（如线性探测、二次探测、双哈希等）在哈希表中查找下一个可用的位置，并将元素存储在那里。
   - 查找时也需要按照相同的探测序列进行，直到找到目标元素或确定元素不存在。
   - 开放寻址法的一个主要缺点是当哈希表变得过于拥挤时，性能会显著下降，因为这会导致大量的探测和可能的聚集现象。

在选择解决哈希冲突的方法时，需要考虑以下因素：

- **哈希表的大小**：哈希表的大小应该足够大，以减少冲突的可能性。如果哈希表太小，那么冲突就会更频繁地发生。
- **装填因子（Load Factor）**：装填因子是哈希表中已存储元素数量与哈希表大小的比值。保持较低的装填因子可以提高哈希表的性能。
- **哈希函数的选择**：一个好的哈希函数应该尽可能均匀地分布输出值，以减少冲突。在实际应用中，可能需要尝试不同的哈希函数来找到最适合特定数据集的那一个。
- **动态调整**：如果哈希表的大小是固定的，并且数据集的大小可能会变化，那么可能需要动态地调整哈希表的大小来保持较低的装填因子和较好的性能。这通常涉及到重新哈希（Rehashing）操作，即将所有元素从一个哈希表重新插入到另一个大小的哈希表中。

### 3.4 简单实现哈希表

```c++
#include <iostream>  
#include <list>  
  
// 键值对结构体  
struct KeyValuePair {  
    int key;  
    int value;  
    KeyValuePair(int k, int v) : key(k), value(v) {}  
};  
  
// 哈希表类  
class HashTable {  
private:  
    std::list<KeyValuePair>* table;  
    int capacity; // 哈希表的大小  
  
    // 哈希函数  
    int hash(int key) {  
        return key % capacity;  
    }  
  
public:  
    // 构造函数  
    HashTable(int size) : capacity(size) {  
        table = new std::list<KeyValuePair>[size];  
    }  
  
    // 析构函数  
    ~HashTable() {  
        delete[] table;  
    }  
  
    // 插入键值对  
    void insert(int key, int value) {  
        int index = hash(key);  
        for (auto it = table[index].begin(); it != table[index].end(); ++it) {  
            if (it->key == key) {  
                it->value = value; // 如果键已存在，则更新值  
                return;  
            }  
        }  
        table[index].push_back(KeyValuePair(key, value)); // 插入新键值对  
    }  
  
    // 根据键获取值  
    int get(int key) {  
        int index = hash(key);  
        for (const auto& pair : table[index]) {  
            if (pair.key == key) {  
                return pair.value;  
            }  
        }  
        // 如果找不到键，则返回特殊值（例如-1）  
        return -1;  
    }  
  
    // 删除键值对  
    void remove(int key) {  
        int index = hash(key);  
        for (auto it = table[index].begin(); it != table[index].end(); ++it) {  
            if (it->key == key) {  
                table[index].erase(it);  
                return;  
            }  
        }  
    }  
  
    // 打印哈希表  
    void display() {  
        for (int i = 0; i < capacity; ++i) {  
            std::cout << i << ": ";  
            for (const auto& pair : table[i]) {  
                std::cout << "(" << pair.key << ", " << pair.value << ") ";  
            }  
            std::cout << std::endl;  
        }  
    }  
};  
  
// 测试哈希表  
int main() {  
    HashTable ht(10); // 创建一个大小为10的哈希表  
  
    // 插入一些键值对  
    ht.insert(1, 100);  
    ht.insert(11, 110);  
    ht.insert(21, 210);  
    ht.insert(31, 310);  
    ht.insert(41, 410);  
  
    // 显示哈希表  
    ht.display();  
  
    // 获取值并输出  
    std::cout << "Value for key 1: " << ht.get(1) << std::endl;  
    std::cout << "Value for key 11: " << ht.get(11) << std::endl;  
  
    // 删除键值对  
    ht.remove(11);  
  
    // 再次显示哈希表  
    ht.display();  
  
    return 0;  
}
```

